# c programming language

- 1 **c和c++区别**
    - c: 面向过程的语言, 其核心关注于问题是如何被解决的, 把实现一个软件功能的过程分为一个个过程. 例如汽车要去加油, 其过程为: 汽车启动->汽车行驶->汽车加油. 在这里我们不关注物件本身(汽车这个对象), 默认定义执行该过程的主题是汽车. 
    - c++:  面向对象的语言, 在计算机科学中的对象既可以表示客观世界的问题空间(namespace)中的具体的某个事物, 又可以表示软件系统解空间的基本元素, 如变量 数据结构 函数等. 例如汽车要去加油, 汽车<启动, 开车, 加油>, 我们关注物件(对象)本身, 只需要考虑什么时间干什么事. 启动, 开车, 加油属于这个物件的基本属性. 

- 2 **c语言编译后内存分为哪几部分?**
    - 栈(stack): 由编译器进行管理, 自动分配和释放, 存放函数调用过程的各种参数, 局部变量, 返回值以及函数的返回地址. 操作方式类似于数据中的栈. 
    - 堆(heap): 用于程序动态申请分配和释放空间. c中的malloc和free, c++中的new和delete均是在堆中进行的. 正常情况下, 程序员申请的空间在使用结束后应该释放, 若程序员没有释放空间, 则在程序结束后由系统自动回收. 注意: 这里的对并不是数据结构中的堆. 
    - 全局(静态)存储区: 分为DATA和BSS段
        - DATA段(全局初始化区)存放初始化的全局变量和静态变量
        - BSS段(全局未初始化分区) 存放未初始化的全局变量和静态变量. 程序运行结束时自动释放, 其中在BSS段在程序执行之前会被系统自动清零, 所以未初始化的全局变量和静态变量在程序执行之前已经为0.
    - 文字常量区: 存放常量字符串, 程序结束由系统释放. 
    - 程序代码区: 存放程序的二进制代码. 

- 3 **定义常量的方法**
    - c语言定义常量使用define或const关键字.
        - 使用#define宏定义: #define LENGTH = 10
        - 使用const关键字: const int LENGTH = 10 或 int const LENGTH = 10
 
    - 区别
        - 宏定义是字符替换, 没有数据类型的区别, 也不会进行类型检查, 可能会产生边际效应等错误; const是常量的声明, 有类型区别, 需要在编译阶段进行类型检查. 
        - 宏定义是"编译时"的一个概念, 在预处理阶段展开, 不能宏定义进行调试, 声明周期结束于编译时期; const是一个"运行时"的概念, 在程序运行的时候使用. 
        - 宏定义是直接替换, 不会分配内存, 存储于程序的代码段中; const需要进行内存分配, 存储于程序的数据段中. 

- 4 **const关键字的用法**
    - 1 const变量
        - 定义的时候就初始化, 以后不能更改
            ```
            const int i = 1;
            const int array = {1, 2, 3}.
            ```
        - const指针
            - 第一种情况const用来修饰*p, (如下代码), const和int可以互换位置. 此时const修饰的是*p, *p代表指针变量所指向内存单元的值, 即*p的值不可被更改, 但p所代表的地址可以被更改.
            ```c
            int i = 1 , j = 2;
            const int *p = &i; // 或者是 int const *p = &i
            *p = 3;  // 此行报错
            p = &j; // 此行运行正常
            ```
            - 第二种情况const用来修饰p, 此时p所存放的内存单元地址不可变, 但所指向内存单元的内容可变. 
            ```c
            int i = 1, j = 2;
            int* const p = &i;
            *p = 3;  //此行运行正常
            p = &j  // 此行报错
            ```
            - 第三种情况是*p和p均被const修饰, 则p存放的内存单元的地址和*p存放的内存单元的内容均不可变. 
            ```c
            int i = 1, j = 2;
            int* const p = &i;
            *p = 3;  //此行报错
            p = &j  // 此行也报错
            ```
    - 2 const function parameter
        - const 形参在函数里不能改变.
        - 防止传入的参数代表的内容在函数体内被改变, 但仅对指针和引用有意义. 因为如果是按值传递, 传给参数的仅仅是实参的副本, 即使在函数体内改变了形参, 实参也不会得到影响. 
        ```c
        void fun(const char * src, char * des){  // 保护源字符串不被修改, 若修改src则编译出错. 
            strcpy(des,src);
        }
        ```
    - 3 const class function
        - 修饰类成员函数, 该函数对成员变量只能进行只读操作, 就是const类成员函数是不能修改成员变量的数值.
        ```c
        class A
        {
            const func1();
        };
        ```
    - 4 Examples
        ```c
        const int a; // a是一个常整数
        int const a; // a是一个常整数
        const int *a; // a是一个指向常整数的指针, 整数不能修改, 指针可以修改
        int *const a; // a是一个指向整数的常指针, 整数可以修改, 指针不能修改
        int const *a const; // a是一个指向常整数的常指针, 整数和指针都不能修改
        ```

- 5 **volatile关键字的作用是什么?**
    - volatile变量表示可以被某些编译器未知的因素修改, 比如操作系统, 硬件或者其他线程等. 因此编辑器不会对该变量的代码段进行优化, 每次用到该变量时, 都会从内存段重新读取. volatile会告诉编译器, 被修饰的变量随时可能发生变化, 因此每次需要从内存中重新读取, 而不是从寄存器中读取备份.
    ```c
    volatile BOOL bStop = False;

    // 线程1, 用来对bStop标志位进行操作. 
    while(!bstop) {...}
    bStop = False;

    //线程2, 等待线程1终止, 如果bStop不使用volatile声明, 则while循环无法退出. 
    bStop = True;
    while(bStop);
    ```
    - volatile的应用场景
        - 一个中断服务的子程序, 会访问到非自动变量.
        - 多线程应用中被几个任务共享的变量.
        - 并行设备的硬件寄存器.

- 6 **头文件中双引号和尖括号的区别是什么?**
    - 编译器预处理阶段查找头文件路径的顺序不一样: 
        使用双引号时: 先搜索源文件所在的工作目录->编译器设置的头文件查找途径->系统变量C_INCLUDE_PATH指定的头文件路径. 
        使用尖括号时: 先搜索编译器设置的头文件查找路径->系统变量C_INCLUDE_PATH指定的头文件路径. 
    - 因此, 在#include引用自己写的头文件时, 只能用双引号, 而引用标准库文件时两种方法都行. 

- 7 在.h的头文件中, #pragma的作用
    #pragma是一种预处理指令, 它的作用是设置编译器的状态或者指定编译器完成一些特定的动作. 其格式一般为 `#pragama parameter`. 

    `#pragma message`: message参数用于在编译信息输出窗口输出相应的信息, 用于源代码的信息控制. 其格式为`#pragma message("SDK 1.01")`. 
    `#pragma once`: 一般用于头文件中, 用来保证头文件只被编译一次. 
    `#pragma code_seg`: 用来设置程序中函数代码存放的代码段. 
    `#pragma pack`: 用来控制内存对齐的方式. `#pragma pack(n)`编译器将按照n个字节进行对齐. `#pragma pack()`编译器将取消自定义字节对齐方式. 

- 8 `#pragma once`和`#ifndef`的区别
    - 在c/c++中, 为了避免了同一个头文件被包含(include)多次有两种宏实现方式: 
    - 第一种是#ifdef的方式, 这种方式受c/c++语言标准支持, 它可以保证同一个文件或者**内容完全相同的文件/代码片段**被包含多次. 但这种定义方式依赖于宏名字不能冲突, 如果宏名冲突, 会导致头文件存在缺报错找不到声明. #ifndef的示例如下:
    ```
    #ifndef __LED_H__
    #define __LED_H__

    #endif
    ```
    - 第二种方式采用#pragma的方式, 这种方式由编译器保证同一个文件(物理意义上的)不会被包含多次, 也不会出现因为宏名冲撞引发的问题. 使用示例:
    ```
    #pragma once

    ```

- 9 **static关键字**
    - c语言中static关键字的常用于三种情况: 修饰局部变量, 修饰全局变量, 修饰函数.
        - static局部变量: static修饰的局部变量只能在函数体内被调用. 并且static局部变量的值不会因为函数调用的结束而清除, 在函数执行完成后不会释放, 继续保留在内存中. 当函数再次调用时, 该变量的值是上次调用结束后的值. static局部变量被存储在静态存储区(局部变量存放在栈中). 并且静态局部变量会被自动初始化为0.
            - 非静态全局变量的作用域是整个源程序, 当一个源程序由多个源文件组成时, 非静态的全局变量在各个源文件中都是有效的. 而静态全局变量则限制了其作用域, 即只在定义该变量的源文件内有效, 在同一源程序的其它源文件中不能使用它.
        - static全局变量: static修饰的全局变量成为静态全局变量. 该变量只能在被当前文件的所有函数访问, 其他文件不能链接或引用static全局变量.
        - static函数: static函数只能在当前文件中被调用, 不能被其他文件调用, 对其他文件不可见. static函数的好处是, 不用担心与其他文件的同名函数相互干扰, 也是一种对于函数的保护机制.

- 10 extern 关键字的作用
    - 在c语言中, 修饰符extern用在变量或者函数的声明前, 用来说明此函数/变量是在别处定义, 但是要再此处引用. 注意extern不能用来修饰局部变量. 具体应用示例: 
        - 在a.c文件中
        ```
        unsigned char key;
        void func(void){...}
        在main.c文件中

        #include "a.h"

        extern unsigned char key;
        extern void func(void);
        int main(){
            if(key == "a")
                func();
            return 0;
        }
        ```

- 11 c语言中的声明和定义
    - 函数和变量的声明不会分配内存, 但定义会分配相应的内存空间. 
    - 函数和变量的声明可以有很多次, 但定义只有一次. 
    - 函数的定义和声明方式都是默认extern的, 即函数默认是全局的. 可以采用static实现对函数的隐藏. 
    - 变量的声明和定义默认都是局部的, 在当前编译单元或者文件中可用. 

- 12 c语言的变量
    - 1 c语言变量的基本类型
        - 五种基本类型: char, int, float, double, void.
        - void是空类型, 一般用于限制函数的返回和参数以及用来定义空指针. 

    - 2 局部变量和全局变量区别?
        - 生存周期不同: 局部变量存在于模块中, 生存期从模块开始到结束. 
        - 存储位置不同: 局部变量保存在栈空间内, 栈地址是不固定的, 由编译器自动分配和释放, 全局变量保存在静态存储区的数据段中. 

    - 3 局部变量和全局变量是否可以重名?
        可以, 但是局部变量会屏蔽全局变量, 如果在程序中使用因为重名被屏蔽的全局变量, 需要在变量前加::. 
        ```
        int a = 10;
        int main()
        {
            int a = 9;
            printf("%d\n", a); //输出局部变量
            printf("%d\n", ::a);  //输出全局变量
            return 0;
        }
        ```

- 13 c语言的数据类型有哪些?
    - 基本类型: 包括整数类型和浮点类型, char属于整数类型. 
    - 派生类型: 包括指针类型, 数组类型, 结构类型, 共用体类型和函数类型. 
    - 枚举类型: 枚举数据类型的作用是让数据更加简洁, 易读. 枚举数据的定义格式为: enum 枚举名 {元素1, 元素2, ...}; 枚举类型中的每一个元素都有其代表的值. 未指定情况下, 第一个枚举元素的默认值为0, 后面每一个元素的值为前一个元素加. 示例如下: 
        ```
        enum DAY{
            MON, TUE, WED=5, THU, FRI, SAT, SUN
        };
        enum DAY day = MON, day1 = THU;
        printf("%d\n", day);  //day的输出是0
        printf("%d\n", day1); //day1的输出是6
        ```
    - void类型: void类型指定没有可用类型的值. 当函数不需要返回值时, 必须使用void限定. 例: void func(int a, char *b); 当函数不允许接受参数时, 必须使用void限定. 例: int func(void); void用来定义指针时, 该指针可以指向任意类型的数据. 

- 14 **预编译**
    - 1 什么是预编译(Precompilation)
        - 预编译是指在编译前对源代码进行预处理, 包括宏展开 头文件展开 条件编译 删除注释等, 从而生成一个**预处理后的代码文件**. 这个过程通常由*预处理器(Preprocessor)*完成, 主要用于 C/C++ 语言.
        - 在 C/C++ 语言中, 预编译通常指*预处理(Preprocessing)*, 由`#`指令控制, 例如: 
            - `#include`: 头文件展开
            - `#define`: 宏定义替换
            - `#ifdef / #ifndef`: 条件编译
            - `#pragma`: 编译器特定指令

    - 2 预编译的主要作用
        - 减少重复编译, 提高编译速度(如预编译头 `precompiled header`).
        - 代码复用(如通过 `#include` 复用头文件).
        - 条件编译(针对不同平台 不同配置编译不同的代码).
        - 宏替换(简化代码, 提高可读性).

    - 3 何时需要预编译
        - (1) 使用头文件较多时
            - 如果工程包含大量头文件, 每次编译都会重新解析这些文件, 影响编译速度. 使用**预编译头(Precompiled Header, PCH)**, 举例: 
            ```c
            // stdafx.h (预编译头)
            #include <iostream>
            #include <vector>
            #include <map>

            // stdafx.cpp
            #include "stdafx.h"
            ```
            - 编译器会对 `stdafx.h` 进行**预编译**, 后续编译其他文件时直接使用, 提高编译速度.

        - (2) 跨平台或多配置编译时
            - 如果程序需要适配多个平台(如 Windows 和 Linux)或多个版本(如 Debug 和 Release), 可以使用条件编译: 
            ```c
            #ifdef _WIN32
                #define OS_NAME "Windows"
            #else
                #define OS_NAME "Linux"
            #endif
            ```
            这样不同平台可使用不同的代码, 而不需要修改主程序. 

        - (3) 避免重复定义和冗余编译
            - 头文件可能被多个源文件 `#include`, 导致重复定义错误或不必要的编译开销. 使用头文件保护宏或 `#pragma once`: 
            ```c
            #ifndef MY_HEADER_H
            #define MY_HEADER_H
            // 头文件内容
            #endif
            ```
            或者: 
            ```cpp
            #pragma once  // 避免头文件被重复包含
            ```

    - 4 预编译 vs. 编译
        | **阶段** | **作用** | **示例** |
        |-----|-----|-----|
        | **预编译(Preprocessing)** | 处理 `#include` `#define` 条件编译等 | `gcc -E source.c -o source.i` |
        | **编译(Compilation)** | 将 `.c` 源码转换为汇编 `.s` | `gcc -S source.i -o source.s` |
        | **汇编(Assembly)** | 将汇编代码转换为机器码 `.o` | `gcc -c source.s -o source.o` |
        | **链接(Linking)** | 生成最终可执行文件 | `gcc source.o -o output` |

    - Summary
        - 预编译主要用于**加快编译速度 避免重复编译 支持条件编译**, 特别是在**大型项目**或**跨平台开发**时非常重要. 在 C++ 中, **预编译头(PCH)**可以显著提高编译性能, 而在一般开发中, 头文件保护和条件编译是常见的预编译方式. 

- 15 c语言如何实现一个频繁使用短小函数, c++如何实现?
    - c语言可以使用宏定义实现一个短小函数, 如下面例子所示. 但是宏定义语句不会进行检查, 并且对书写格式有过分的讲究. 比如MAX和括号之间不能有空格, 每个参数都要放在括号里. 尽管如此, 仍然会因为没有参数类型检查造成错误. 
        ```
        #define MAX(a, b) ((a)>(b)?(a):(b))

        int main(){
            int a=1, b=0, c=0;
            c = MAX(a, b); //程序运行正常
            c = MAX(a, "Hello"); //未进行类型检查, 将错误的比较int和字符串. 
            c = MAX(a++, b);  //a被增值两次, 结果: c=2, a=3
            c = MAX(a++, b+10);  //a增值一次, 结果: c=10, a=2
        }
        ```
    - c++使用内联函数来实现, 内联函数被编译器自动的以函数的形式添加进代码, 因此会正常的进行参数检查. 并且内联函数可以提高函数的使用效率. 但是要注意内联函数不允许使用循环语句和开关语句, 通常情况下, 内联函数都是1-5行的小函数. 
    ```
    inline int MAX(int a, int b){
        return a>b?a:b;
    }
    ```

- 16 i++和++i去别, 哪个速度更快?
    - ++/--属于C/c++中的自增运算符, 表示操作数增/减一. 一般自增运算符有两种写法: i++ / ++i. 
    - 区别: 
        - 用在独立的语句中: i++和++i没有区别. 
        - 用在赋值表达式中: y=i++表示先给y赋值, i自身再加一; y=++i表示先i自身加一再赋值给y. 
    - 速度上: ++i的速度比较快, 详细的流程如下: 
        ```
        // i++等效于
        int j = i;
        i = i + 1;
        return j

        //++i相当于
        i = i + 1;
        return i;
        ```

- 17 new和malloc
    - 属性
        - new/delete是c++关键字, 需要编译器的支持.
        - malloc/free是c/c++的库函数, 需要头文件`<stdlib.h>`的支持. 
    - 参数
        - new操作符申请内存分配时无需指定内存块的大小, 编译器会根据类型的信息自行计算.
        - malloc则需要显式的指出所需内存的尺寸. 
    - 返回类型的安全性
        - new操作符内存分配成功时, 返回的是对象类型的指针类型严格与对象匹配, 无需进行类型转换, 因此new是符合类型安全性的操作符.
        - malloc内存分配成功返回的是`void *`类型的指针, 需要通过强制的类型转换将指针转换成所需要的类型. 
    - 分配失败的返回值
        - new内存分配失败的时候会跑出mac_alloc异常.
        - malloc分配内存失败的时候会返回 Null.
    - 自定义类型
        - new会先调用operator new函数, 申请足够的内存(通常底层使用malloc实现), 然后调用类型的构造函数初始化的成员变量, 最后返回自定义类型的指针. delete会先调用析构函数, 然后调用operator delete函数释放内存(通常底层采用free实现). 
    - 申请的内存所在位置
        - new操作符从自由存储区(free store)上为对象动态的分配内存空间, 自由存储区是基于c++的new操作符的抽象概念, 范式通过new操作符进行内存申请, 该内存即为自由存储区.
        - malloc函数从堆上分配内存, c语言使用malloc从堆上分配内存, 使用free释放已分配的相应内存. 堆是操作系统中的术语, 是操作系统所维护的一种特殊内存, 用于程序内存的动态分配.
        - 自由存储区不等于堆. 
    - 重载
        - c++允许重载new/delete操作符, new不需要为对象分配内存, 而是指定了一个地址作为内存的起始区域, new在这段内存上为对象调用构造函数完成初始化过程, 并返回此地址.
        - malloc不允许重载.
    - 具体过程
        - c语言通过malloc可以向程序的虚拟空间申请一块虚拟地址空间, 与物理内存没有直接关系, 得到的是在虚拟空间中的地址, 之后程序运行所提供的物理内存是由操作系统分配的.

- 18 `sizeof(struct)`和`strlen(union)`的内存对齐问题
    - 1 内存对齐的作用
        - 平台问题: 很多硬件平台都能访问任意地址上的任意数据, 某些硬件平台智能在特定地址的位置获取特定类型的数据, 否则会抛出异常.
        - 性能原因: 数据结构(特别是栈), 应该尽量在自然边界上对齐. 因为要访问未对齐的内存, 处理器需要作两次内存访问, 而对于对齐的内存访问则只需要一次.
    - 2 sizeof和strlen的区别
        - sizeof返回的是一个对象或类型占用的内存字节数, 如果是`sizeof(*pointer)`, 只会返回4个字节.
        - strlen仅对字符串有效, 计算由开始位置到`'\0'`的计数结果.
    - 3 struct的内存对齐
        - 对于结构体的各个成员, 第一个成员的偏移量是0, 排列在后面的成员其当前偏移量必须是当前成员类型的整数倍.
        - 结构体内所有数据成员各自内存对齐后, 结构体本身还要进行一次内存对齐, 保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍.
        - 如程序中有`#pragma pack(n)`预编译指令, 则所有成员对齐以n字节为准(即偏移量是n的整数倍), 不再考虑当前类型以及最大结构体内类型.
        ```c
        #pragma pack(i)

        struct s {
            int ld; // 4
            char c; // 1
            unsigned short i; // 2
            char *str; // 4
            void(*func)(void); // 4
        }
        ```
        - 32位编译, 最长类型是int, 是4字节对齐, 16字节. (按多少节对齐, 是根据结构体的最长类型决定的, 这里是int是最长的字节, 所以按4字节对齐).
        - 使用64位编译, int 4, char 1, unsigned short 2, char* 占8, 函数指针占8个, 由于是64位编译是8字节对齐, 该结构体占24个字节.
    - 4 union的内存对齐
        - 找到占用字节最多的成员.
        - union的字节数必须是占用字节最多的成员的字节的倍数, 而且需要能够容纳其他的成员.
        ```c
        typedef union {
            long i;
            int k[5];
            char c;
        }
        ```
        - 要计算union的大小, 首先要找到占用字节最多的成员, long 8个, int k[5] 4. 
        - union的字节数必须是占用字节最多的成员的字节的倍数, 且需要能够容纳其他的成员, 为了要容纳k(20个字节), 就必须要保证是8的倍数的同时还要大于20个字节, 所以是24个字节.

- 19 位域
    - c允许在一个结构体中以位为单位来指定其成员所占内存长度, 这种以位为单位的成员称为"位段"或称"位域"(bit field). 利用位段能够用较少的位数存储数据. 一个位段必须存储在同一存储单元中, 不能跨两个单元. 如果第一个单元空间不能容纳下一个位段, 则该空间不用, 而从下一个单元起存放该位段.
        - 位段声明和结构体类似.
        - 位段的成员必须是int、unsigned int、signed int.
        - 位段的成员名后边有一个冒号和一个数字.
        ```c
        typedef struct_data{
            char m:3;
            char n:5;
            short s;          
            union{
                int a;
                char b;
            };    
            int h;
            }_attribute_((packed)) data_t;
        ```
        - m和n一起, 刚好占用一个字节内存, 因为后面是short类型变量, 所以在short s之前已经有了1字节. 所以m和n其实是占了两个字节的, 然后是short两个个字节, 加起来就4个字节, 然后联合体占了四个字节, 总共8个字节了, 最后int h占了四个字节, 就是12个字节了.

- 20 `attribute`关键字
    - __attribute__主要用来在函数或数据声明中设置其属性. GNU c的一大特色就是__attribute__机制. __attribute__可以设置函数属性(Function Attribute), 变量属性(Variable Attribute)和类型属性(Type Attribute).

    - __attribute__语法格式
        - `__attribute__ ((attribute-list))`
        - 函数属性(Function Attribute)
            - 函数属性可以帮助开发者把一些特性添加到函数声明中, 从而可以使编译器在错误检查方面的功能更强大.

        - 变量属性(Variable Attributes)
            - 关键字`__attribute__`也可以对变量(variable)或结构体成员(structure field)进行属性设置. 在使用__attribute__参数时, 你也可以在参数的前后都加上`__`(两个下划线). 例如, 使用__aligned__而不是aligned, 这样就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义.

        - 类型属性(Type Attribute)
            - 关键字__attribute__也可以对结构体(struct)或共用体(union)进行属性设置. 大致有六个参数值可以被设定: aligned, packed, transparent_union, unused, deprecated, may_alias.

        - 在跨平台通信时, 由于不同平台内存对齐方式不同, 如果使用结构体进行平台间的通信会有问题. 例如, 发送消息的平台上, 结构体为24字节, 接受消息的平台上, 此结构体为32字节(举例), 那么每个变量对应的值就不对了. 不同框架的处理器对齐方式会有不同, 这个时候不指定对齐的话, 会产生错误结果.

- 21 inline关键字
    - 在c语言里, 如果一些函数被频繁调用, 不断地有函数入栈(即函数栈), 会造成栈空间或栈内存的大量消耗. 为了解决这个问题, 特别的引入了inline修饰符, 表示为内联函数.
    - 在大多数机器上, 调用函数都要做很多工作: 调用前要先保存寄存器, 并在返回时恢复, 复制实参, 程序还必须转向一个新位置执行c++中支持内联函数, 其目的是为了提高函数的执行效率. 用关键字 inline 放在函数定义(注意是定义而非声明)的前面即可将函数指定为内联函数, 内联函数通常就是将它在程序中的每个调用点上"内联地"展开.
    - 内联是以代码膨胀(复制)为代价, 仅仅省去了函数调用的开销, 从而提高函数的执行效率.

- 22 在 C/C++ 语言的程序执行过程中, 内存的四个区
    - 1 代码区(Text Segment/Code Segment)
        - 存放内容: 程序的机器指令(即编译后的代码), 只读常量(例如 `const char *str = "hello";` 中的 `"hello"`).
        - 特点: 只读(防止程序意外修改代码), 共享(多个进程可共享相同的代码段, 如动态库).
        - 变量类型
          - 代码本身(CPU 指令).
          - 只读字符串字面量(如 `"hello"`).
          ```c
          const char *str = "hello"; // "hello" 存在代码区
          ```

    - 2 数据区(Data Segment)
        1 静态区(.data 段, 已初始化的全局变量和静态变量)
        2 BSS段(.bss 段, 未初始化的全局变量和静态变量)

        - (1).data 段**
            - 内容: 已初始化的全局变量和静态变量(包括 `static` 关键字声明的变量).
            - 生命周期: 程序启动时分配, 程序结束时释放.
            ```c
            int global_var = 10;  // 已初始化的全局变量, 存放在 .data 段
            static int static_var = 20; // 静态变量, 存放在 .data 段
            ```
        - (2).bss 段**
            - 存放内容: 未初始化的全局变量和静态变量(默认初始化为 `0`).
            - 特点: 由于未初始化, 程序加载时会被清零.
            ```c
            int uninitialized_var; // 未初始化的全局变量, 存放在 .bss 段
            static int static_uninitialized_var; // 未初始化的静态变量, 存放在 .bss 段
            ```

    - 3 堆(Heap Segment)
    - 存放内容: 动态分配的内存(`malloc()`、`new`).
    - 管理方式: 手动管理, 程序员必须显式 `free()` / `delete` 释放.
    - 特点: 大小不固定, 由程序运行时动态分配; 可能造成内存泄漏(未释放的内存会一直占用).
    ```c
    int *p = (int *)malloc(sizeof(int)); // 堆区
    free(p); // 释放
    ```

    - 4 栈(Stack Segment)
    - 存放内容: 局部变量(非 `static` 修饰); 函数参数; 返回地址.
    - 特点: 
      - 自动分配和释放(函数调用时分配, 函数返回时自动回收).
      - 速度快(比堆分配快, 直接在栈指针上操作).
      - 有限制(栈空间较小, 过多递归或大数组会导致栈溢出).
      ```c
      void func() {
          int local_var = 10; // 局部变量, 存放在栈区
      }
      ```

    - Summary
    | **内存区域** | **存放内容** | **分配方式** | **释放方式** | **示例** |
    |--------------|-------------|-------------|-------------|-------------|
    | **代码区** | 机器指令、只读常量 | 由操作系统分配 | 由操作系统释放 | `const char *s = "hello";` |
    | **数据区**(.data & .bss) | 全局变量、静态变量 | 程序启动时分配 | 程序结束时释放 | `static int a = 10;` |
    | **堆区** | `malloc()` / `new` 动态分配的内存 | `malloc()` / `new` | `free()` / `delete` | `int *p = malloc(4);` |
    | **栈区** | 局部变量、函数参数 | 函数调用时自动分配 | 函数返回时自动释放 | `void foo() { int x; }` |

    - Problems
        (1) 栈溢出(Stack Overflow)
           - 递归深度过大或局部变量太多会导致栈溢出
           ```c
           void recursive() {
               int arr[1000000]; // 栈空间不够, 可能导致栈溢出
               recursive(); // 递归太深也会导致栈溢出
           }
           ```

        (2) 内存泄漏(Memory Leak)
           - 堆上的内存未释放会造成内存泄漏
           ```c
           void leak() {
               int *p = (int *)malloc(sizeof(int));
               // 忘记 free(p); 会导致内存泄漏
           }
           ```

        3 堆和栈的区别
           | **比较项** | **堆(Heap)** | **栈(Stack)** |
           |------------|--------------|--------------|
           | **管理方式** | **手动管理**(`malloc/free`) | **自动管理** |
           | **访问速度** | **较慢**(需要指针访问) | **较快**(直接访问) |
           | **空间大小** | **较大**(受限于系统内存) | **较小**(通常几 MB) |
           | **使用场景** | 需要动态内存分配, 如链表 | 局部变量、函数参数 |


- 23 程序从代码到可执行文件

    - 一个程序从**源代码**到**可执行文件**的完整过程, 通常包括 **预处理(Pre-Processing)、编译(Compiling)、汇编(Assembling)、链接(Linking)** 四个阶段.  

    - 1 预处理(Pre-Processing)
        作用: 处理 `#` 开头的指令(宏、头文件、条件编译等).
        输入: 源代码文件(`.c`、`.cpp`).  
        输出: 预处理后的代码(`.i` 文件).  

        - 主要任务
        - 宏替换(`#define`): 替换宏定义的内容.
        - 头文件展开(`#include`): 将头文件的内容插入代码.
        - 条件编译(`#ifdef`、`#ifndef`): 根据宏条件决定是否编译代码.
        - 删除注释.

        ```c
        #include <stdio.h>
        #define PI 3.14

        int main() {
            printf("Pi is %f\n", PI);
            return 0;
        }
        ```
        预处理后 `hello.i`
        ```c
        extern int printf(const char *, ...);

        int main() {
            printf("Pi is %f\n", 3.14);
            return 0;
        }
        ```

        ```sh
        gcc -E hello.c -o hello.i
        ```

    - 2 编译(Compiling)
        作用: 将预处理后的 c 转换为汇编(`.s` 文件). 
        输入: 预处理后的代码(`.i` 文件).
        输出: 汇编代码(`.s` 文件).

        ```assembly
        .section    .rodata
        .LC0:
            .string "Pi is %f\n"
            
        main:
            pushl   %ebp
            movl    %esp, %ebp
            subl    $8, %esp
            fldl    .LC1
            fstpl   -8(%ebp)
            pushl   -8(%ebp)
            pushl   $.LC0
            call    printf
            addl    $8, %esp
            movl    $0, %eax
            leave
            ret
        ```

        ```sh
        gcc -S hello.i -o hello.s
        ```

    - 3 汇编(Assembling)
        作用: 将汇编转换为机器代码(二进制文件), 生成目标文件(`.o` 文件).
        输入: 汇编代码(`.s` 文件).
        输出: 目标文件(`.o` 文件).

        ```sh
        gcc -c hello.s -o hello.o
        ```
        此时, `hello.o` 是一个二进制文件, 包含机器指令, 但尚未完成链接.

    - 4 链接(Linking)
        作用: 将多个目标文件和库文件合并, 生成**最终可执行文件**(`.exe` 或 `a.out`).
        输入: 目标文件(`.o` 文件).
        输出: 可执行文件(`a.out`、`.exe`).

        - 主要任务
            - 符号解析: 解决**函数、全局变量**的引用.
            - 合并多个 `.o` 文件: 将多个目标文件整合.
            - 加载标准库(如 `printf` 需要 `libc`).
            - 重定位: 计算内存地址, 确保程序能正确运行.

        ```sh
        gcc hello.o -o hello
        ./hello
        ```

    - Summary
    | **阶段** | **命令** | **作用** | **输入** | **输出** |
    |----------|---------|---------|---------|---------|
    | **预处理(Pre-Processing)** | `gcc -E hello.c -o hello.i` | 处理 `#define`、`#include`、条件编译 | `.c` 源文件 | `.i` 预处理文件 |
    | **编译(Compiling)** | `gcc -S hello.i -o hello.s` | 将 C 代码转为汇编代码 | `.i` 预处理文件 | `.s` 汇编代码 |
    | **汇编(Assembling)** | `gcc -c hello.s -o hello.o` | 汇编, 生成机器代码 | `.s` 汇编代码 | `.o` 目标文件 |
    | **链接(Linking)** | `gcc hello.o -o hello` | 解决符号、合并目标文件, 生成可执行文件 | `.o` 目标文件 | `a.out` 可执行文件 |
