# c programming language

- 1 **c和c++区别**
    - c: 面向过程的语言, 其核心关注于问题是如何被解决的, 把实现一个软件功能的过程分为一个个过程. 例如汽车要去加油, 其过程为: 汽车启动->汽车行驶->汽车加油. 在这里我们不关注物件本身(汽车这个对象), 默认定义执行该过程的主题是汽车. 
    - c++:  面向对象的语言, 在计算机科学中的对象既可以表示客观世界的问题空间(namespace)中的具体的某个事物, 又可以表示软件系统解空间的基本元素, 如变量、数据结构、函数等. 例如汽车要去加油, 汽车<启动, 开车, 加油>, 我们关注物件(对象)本身, 只需要考虑什么时间干什么事. 启动, 开车, 加油属于这个物件的基本属性. 

- 2 **c语言编译后内存分为哪几部分?**
    - 栈(stack): 由编译器进行管理, 自动分配和释放, 存放函数调用过程的各种参数, 局部变量, 返回值以及函数的返回地址. 操作方式类似于数据中的栈. 
    - 堆(heap): 用于程序动态申请分配和释放空间. c中的malloc和free, c++中的new和delete均是在堆中进行的. 正常情况下, 程序员申请的空间在使用结束后应该释放, 若程序员没有释放空间, 则在程序结束后由系统自动回收. 注意: 这里的对并不是数据结构中的堆. 
    - 全局(静态)存储区: 分为DATA和BSS段
        - DATA段(全局初始化区)存放初始化的全局变量和静态变量
        - BSS段(全局未初始化分区) 存放未初始化的全局变量和静态变量. 程序运行结束时自动释放, 其中在BSS段在程序执行之前会被系统自动清零, 所以未初始化的全局变量和静态变量在程序执行之前已经为0.
    - 文字常量区: 存放常量字符串, 程序结束由系统释放. 
    - 程序代码区: 存放程序的二进制代码. 

- 3 **定义常量的方法**
    - c语言定义常量使用define或const关键字.
        - 使用#define宏定义: #define LENGTH = 10
        - 使用const关键字: const int LENGTH = 10 或 int const LENGTH = 10
 
    - 区别
        - 宏定义是字符替换, 没有数据类型的区别, 也不会进行类型检查, 可能会产生边际效应等错误; const是常量的声明, 有类型区别, 需要在编译阶段进行类型检查. 
        - 宏定义是"编译时"的一个概念, 在预处理阶段展开, 不能宏定义进行调试, 声明周期结束于编译时期; const是一个"运行时"的概念, 在程序运行的时候使用. 
        - 宏定义是直接替换, 不会分配内存, 存储于程序的代码段中; const需要进行内存分配, 存储于程序的数据段中. 

- 4 **const关键字的用法**
    - 1 修饰变量, 数组
        - 被修饰的变量和数组只具有只读属性, 不可被更改(也就是变成了常量数组).
            ```
            const int i = 1;
            const int array = {1, 2, 3}.
            ```
        - const修饰指针的时候有三种情况: 
            - 第一种情况const用来修饰*p, (如下代码), const和int可以互换位置. 此时const修饰的是*p, *p代表指针变量所指向内存单元的值, 即*p的值不可被更改, 但p所代表的地址可以被更改.
            ```
            int i = 1 , j = 2;
            const int *p = &i; // 或者是 int const *p = &i
            *p = 3;  // 此行报错
            p = &j; // 此行运行正常
            ```
            - 第二种情况const用来修饰p, 此时p所存放的内存单元地址不可变, 但所指向内存单元的内容可变. 
            ```
            int i = 1, j = 2;
            int* const p = &i;
            *p = 3;  //此行运行正常
            p = &j  // 此行报错
            ```
            - 第三种情况是*p和p均被const修饰, 则p存放的内存单元的地址和*p存放的内存单元的内容均不可变. 
            ```
            int i = 1, j = 2;
            int* const p = &i;
            *p = 3;  //此行报错
            p = &j  // 此行也报错
            ```
    - 2 修饰函数的入口参数: 防止传入的参数代表的内容在函数体内被改变, 但仅对指针和引用有意义. 因为如果是按值传递, 传给参数的仅仅是实参的副本, 即使在函数体内改变了形参, 实参也不会得到影响. 
        ```
        void fun(const char * src, char * des){  // 保护源字符串不被修改, 若修改src则编译出错. 
            strcpy(des,src);
        }
        ```

- 5 **volatile关键字的作用是什么?**
    - volatile单词是易变的, 不稳定得意思. volatile关键词修饰的变量表示可以被某些编译器未知的因素修改, 比如操作系统, 硬件或者其他线程等. 因此编辑器不会对该变量的代码段进行优化, 每次用到该变量时, 都会从内存段重新读取.  总结来说volatile可以告诉编译器, 被修饰的变量随时可能发生变化, 因此每次需要重新读取, 来保证对特殊地址的稳定访问. 
    ```
    volatile BOOL bStop = False;

    // 线程1, 用来对bStop标志位进行操作. 
    while(!bstop) {...}
    bStop = False;

    //线程2, 等待线程1终止, 如果bStop不使用volatile声明, 则while循环无法退出. 
    bStop = True;
    while(bStop);
    ```

    - volatile的应用场景
        - 中断服务程序中修改的供其他程序检测的变量需要加volatile
        - 多任务环境下各任务间共享的标志也应该加volatile, 如多线程中的共享标志位. 
        - 存储器映射的硬件寄存器也要加volatile声明, 因为每次对它的读写都可能由不同的意义. 

- 6 **头文件中双引号和尖括号的区别是什么?**
    - 编译器预处理阶段查找头文件路径的顺序不一样: 
        使用双引号时: 先搜索源文件所在的工作目录->编译器设置的头文件查找途径->系统变量C_INCLUDE_PATH指定的头文件路径. 
        使用尖括号时: 先搜索编译器设置的头文件查找路径->系统变量C_INCLUDE_PATH指定的头文件路径. 
    - 因此, 在#include引用自己写的头文件时, 只能用双引号, 而引用标准库文件时两种方法都行. 

- 7 在.h的头文件中, #pragma的作用
    #pragma是一种预处理指令, 它的作用是设置编译器的状态或者指定编译器完成一些特定的动作. 其格式一般为 `#pragama parameter`. 

    `#pragma message`: message参数用于在编译信息输出窗口输出相应的信息, 用于源代码的信息控制. 其格式为`#pragma message("SDK 1.01")`. 
    `#pragma once`: 一般用于头文件中, 用来保证头文件只被编译一次. 
    `#pragma code_seg`: 用来设置程序中函数代码存放的代码段. 
    `#pragma pack`: 用来控制内存对齐的方式. `#pragma pack(n)`编译器将按照n个字节进行对齐. `#pragma pack()`编译器将取消自定义字节对齐方式. 

- 8 `#pragma once`和`#ifndef`的区别
    - 在c/c++中, 为了避免了同一个头文件被包含(include)多次有两种宏实现方式: 
    - 第一种是#ifdef的方式, 这种方式受c/c++语言标准支持, 它可以保证同一个文件或者**内容完全相同的文件/代码片段**被包含多次. 但这种定义方式依赖于宏名字不能冲突, 如果宏名冲突, 会导致头文件存在缺报错找不到声明. #ifndef的示例如下:
    ```
    #ifndef __LED_H__
    #define __LED_H__

    #endif
    ```
    - 第二种方式采用#pragma的方式, 这种方式由编译器保证同一个文件(物理意义上的)不会被包含多次, 也不会出现因为宏名冲撞引发的问题. 使用示例:
    ```
    #pragma once

    ```

- 9 static 关键字的作用
    - c语言中static关键字的常用于三种情况: 修饰局部变量, 修饰全局变量, 修饰函数.
        - static用于局部变量修饰符: 被static修饰的局部变量只能在函数体内被调用. 并且静态局部变量的值不会因为函数调用的结束而清除. 当函数再次调用时, 该变量的值是上次调用结束后的值. 静态局部变量被存储在静态存储区(局部变量存放在栈中). 并且静态局部变量会被自动初始化为0. 
        - static用于全局变量修饰符: static修饰的全局变量成为静态全局变量. 该变量只能在被当前文件的所有函数访问, 不可以被其他文件内的函数访问. 
        - static用于函数修饰符: 被static修饰的函数成为静态函数. 同样静态函数只能在当前文件中被调用, 不能被其他文件调用. 

- 10 extern 关键字的作用
    - 在c语言中, 修饰符extern用在变量或者函数的声明前, 用来说明此函数/变量是在别处定义, 但是要再此处引用. 注意extern不能用来修饰局部变量. 具体应用示例: 
        - 在a.c文件中
        ```
        unsigned char key;
        void func(void){...}
        在main.c文件中

        #include "a.h"

        extern unsigned char key;
        extern void func(void);
        int main(){
            if(key == "a")
                func();
            return 0;
        }
        ```

- 11 c语言中的声明和定义
    - 函数和变量的声明不会分配内存, 但定义会分配相应的内存空间. 
    - 函数和变量的声明可以有很多次, 但定义只有一次. 
    - 函数的定义和声明方式都是默认extern的, 即函数默认是全局的. 可以采用static实现对函数的隐藏. 
    - 变量的声明和定义默认都是局部的, 在当前编译单元或者文件中可用. 

- 12 c语言的变量
    - 1 c语言变量的基本类型
        - 五种基本类型: char, int, float, double, void.
        - void是空类型, 一般用于限制函数的返回和参数以及用来定义空指针. 

    - 2 局部变量和全局变量区别?
        - 生存周期不同: 局部变量存在于模块中, 生存期从模块开始到结束. 
        - 存储位置不同: 局部变量保存在栈空间内, 栈地址是不固定的, 由编译器自动分配和释放, 全局变量保存在静态存储区的数据段中. 

    - 3 局部变量和全局变量是否可以重名?
        可以, 但是局部变量会屏蔽全局变量, 如果在程序中使用因为重名被屏蔽的全局变量, 需要在变量前加::. 
        ```
        int a = 10;
        int main()
        {
            int a = 9;
            printf("%d\n", a); //输出局部变量
            printf("%d\n", ::a);  //输出全局变量
            return 0;
        }
        ```

- 13 c语言的数据类型有哪些?
    - 基本类型: 包括整数类型和浮点类型, char属于整数类型. 
    - 派生类型: 包括指针类型, 数组类型, 结构类型, 共用体类型和函数类型. 
    - 枚举类型: 枚举数据类型的作用是让数据更加简洁, 易读. 枚举数据的定义格式为: enum 枚举名 {元素1, 元素2, ...}; 枚举类型中的每一个元素都有其代表的值. 未指定情况下, 第一个枚举元素的默认值为0, 后面每一个元素的值为前一个元素加. 示例如下: 
        ```
        enum DAY{
            MON, TUE, WED=5, THU, FRI, SAT, SUN
        };
        enum DAY day = MON, day1 = THU;
        printf("%d\n", day);  //day的输出是0
        printf("%d\n", day1); //day1的输出是6
        ```
    - void类型: void类型指定没有可用类型的值. 当函数不需要返回值时, 必须使用void限定. 例: void func(int a, char *b); 当函数不允许接受参数时, 必须使用void限定. 例: int func(void); void用来定义指针时, 该指针可以指向任意类型的数据. 

- 14 什么是预处理, 何时要预处理?
    - c预处理器不是编译器的组成部分, 而是编译过程的一个单独步骤, 主要指的是程序执行前#开头的指令的一些工作. 主要包括: #include,#define, #ifdef, #ifndef, #if/#elif/#else/#endif, #error, #pragma. 简言之, C预处理器(C Preprocessor)只不过是一个文本替换的工具, 其目的是指示编译器在实际编译之前完成所需的预处理. 

- 15 c语言如何实现一个频繁使用短小函数, c++如何实现?
    - c语言可以使用宏定义实现一个短小函数, 如下面例子所示. 但是宏定义语句不会进行检查, 并且对书写格式有过分的讲究. 比如MAX和括号之间不能有空格, 每个参数都要放在括号里. 尽管如此, 仍然会因为没有参数类型检查造成错误. 
        ```
        #define MAX(a, b) ((a)>(b)?(a):(b))

        int main(){
            int a=1, b=0, c=0;
            c = MAX(a, b); //程序运行正常
            c = MAX(a, "Hello"); //未进行类型检查, 将错误的比较int和字符串. 
            c = MAX(a++, b);  //a被增值两次, 结果: c=2, a=3
            c = MAX(a++, b+10);  //a增值一次, 结果: c=10, a=2
        }
        ```
    - c++使用内联函数来实现, 内联函数被编译器自动的以函数的形式添加进代码, 因此会正常的进行参数检查. 并且内联函数可以提高函数的使用效率. 但是要注意内联函数不允许使用循环语句和开关语句, 通常情况下, 内联函数都是1-5行的小函数. 
    ```
    inline int MAX(int a, int b){
        return a>b?a:b;
    }
    ```

- 16 i++和++i去别, 哪个速度更快?
    - ++/--属于C/c++中的自增运算符, 表示操作数增/减一. 一般自增运算符有两种写法: i++ / ++i. 
    - 区别: 
        - 用在独立的语句中: i++和++i没有区别. 
        - 用在赋值表达式中: y=i++表示先给y赋值, i自身再加一; y=++i表示先i自身加一再赋值给y. 
    - 速度上: ++i的速度比较快, 详细的流程如下: 
        ```
        // i++等效于
        int j = i;
        i = i + 1;
        return j

        //++i相当于
        i = i + 1;
        return i;
        ```

- 17 new和malloc的区别?
    - 属性: new/delete是c++关键字, 需要编译器的支持, malloc/free是库函数需要头文件的支持. 
    - 参数: 使用new操作符申请内存分配时无需指定内存块的大小, 编译器会根据类型的信息自行计算. 然而malloc则需要显式的指出所需内存的尺寸. 
    - 返回类型的安全性: new操作符内存分配成功时, 返回的是对象类型的指针、类型严格与对象匹配, 无需进行类型转换, 因此new是符合类型安全性的操作符. malloc内存分配成功返回的是 void *类型的指针, 需要通过强制的类型转换将指针转换成所需要的类型. 
    - 分配失败的返回值: new内存分配失败的时候会跑出mac_alloc异常, malloc分配内存失败的时候会返回Null.
    - 自定义类型: new会先调用operator new函数, 申请足够的内存(通常底层使用malloc实现). 然后调用类型的构造函数初始化的成员变量, 最后返回自定义类型的指针. delete会先调用析构函数, 然后调用operator delete函数释放内存(通常底层采用free实现). 
    - 申请的内存所在位置: new操作符从自由存储区(free store)上为对象动态的分配内存空间, 然而malloc函数从堆上分配内存. 自由存储区是基于c++的new操作符的抽象概念, 范式通过new操作符进行内存申请, 该内存即为自由存储区. 而堆是操作系统中的术语, 是操作系统所维护的一种特殊内存, 用于程序内存的动态分配. c语言使用malloc从堆上分配内存, 使用free释放已分配的相应内存. 自由存储区不等于堆. 
    - 重载: c++允许重载new/delete操作符. 布局new的就不需要为对象分配内存, 而是指定了一个地址作为内存的起始区域, new在这段内存上为对象调用构造函数完成初始化过程, 并返回此地址. malloc不允许重载.
